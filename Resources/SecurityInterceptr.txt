package com.kau.dgscalender.common;

import java.time.LocalDateTime;
import java.util.UUID;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.http.HttpStatus;
import org.apache.logging.log4j.CloseableThreadContext;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import com.kau.dgscalender.exception.BusinessException;
import com.kau.dgscalender.service.BaseService;
import com.kau.dgscalender.service.JWTService;
import com.kau.dgscalender.service.UserService;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import lombok.extern.apachecommons.CommonsLog;

@CommonsLog
@Component
public class SecurityInterceptor  extends BaseService implements HandlerInterceptor {
	@Autowired
	protected JWTService jwtservice;
	@Autowired
	private UserService userService;
	@Override
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
			throws Exception {
		String randomId = UUID.randomUUID().toString();
		String ip = request.getRemoteAddr();
		request.setAttribute("ID", randomId);
		try (final CloseableThreadContext.Instance ctc = CloseableThreadContext.put("id", randomId)) {
			log.info("Message 1");
//			log.debug("Message 2");

			if (request.getHeader("session-token") == null) {
				response.setStatus(HttpStatus.SC_UNAUTHORIZED);
				log.error("For Request:" + request.getRequestURL().toString() + " ,NO Session Token.");
				return false;
			} else {
				Jws<Claims> tokenInfo = null;
				try {
					tokenInfo = jwtservice.decodeJWT(request);
				} catch (BusinessException e) {
					if (e.getMessage().contains("JWT expired at")) {
						response.setStatus(HttpStatus.SC_REQUESTED_RANGE_NOT_SATISFIABLE);
						log.debug("For Request:" + request.getRequestURL().toString() + " ,Session Expired.");
						return false;
					}
					response.setStatus(HttpStatus.SC_UNAUTHORIZED);
					log.debug("For Request:" + request.getRequestURL().toString() + " ,Invalid Session Signature.");
					return false;
				}


				request.setAttribute("tokenData", tokenInfo.getBody());

				
				String operation = userService.checkPrivilegesAccess(request, tokenInfo);
				if (operation == null) {
					response.setStatus(HttpStatus.SC_NOT_ACCEPTABLE);
					log.debug("For Request:" + request.getRequestURL().toString() + " ,Session = "
							+ request.getHeader("session-token") + "Access Deined For this Privilage");
					return false;
				}

				request.setAttribute("username", tokenInfo.getBody().get("username"));
				request.setAttribute("operation", operation);

				return true;

			}
		}

	}

	@Override
	public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
			ModelAndView modelAndView) throws Exception {

	}

	@Override
	public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,
			Exception exception) throws Exception {
		try (final CloseableThreadContext.Instance ctc = CloseableThreadContext
				.put("id", request.getAttribute("ID").toString())) {			
		}

	}


}
